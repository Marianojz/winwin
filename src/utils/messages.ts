// Sistema de mensajer√≠a entre admin y usuarios
import { ref, push, set as firebaseSet, get as firebaseGet, update, onValue, off, remove } from 'firebase/database';
import { realtimeDb } from '../config/firebase';
import { Message, Conversation } from '../types';
import { getTemplateByType, renderTemplate } from './messageTemplates';

export const createMessage = (
  fromUserId: string,
  fromUsername: string,
  toUserId: string,
  content: string,
  options: {
    relatedAuctionId?: string;
    relatedProductId?: string;
    relatedOrderId?: string;
    isAutoGenerated?: boolean;
  } = {}
): Message => {
  const conversationId = toUserId === 'admin' ? `admin_${fromUserId}` : `admin_${toUserId}`;
  
  return {
    id: `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    conversationId,
    fromUserId,
    fromUsername,
    toUserId,
    content,
    read: false,
    createdAt: new Date(),
    ...options
  };
};

export const saveMessage = async (message: Message): Promise<Message> => {
  try {
    // Convertir createdAt a Date
    const newMessage = {
      ...message,
      createdAt: message.createdAt instanceof Date ? message.createdAt : new Date(message.createdAt)
    };
    
    // Filtrar campos undefined (Firebase no los permite)
    const messageToSave: any = {
      id: newMessage.id,
      conversationId: newMessage.conversationId,
      fromUserId: newMessage.fromUserId,
      fromUsername: newMessage.fromUsername,
      toUserId: newMessage.toUserId,
      content: newMessage.content,
      read: newMessage.read || false,
      createdAt: newMessage.createdAt.toISOString()
    };
    
    // Solo agregar campos opcionales si no son undefined
    if (newMessage.relatedAuctionId !== undefined) {
      messageToSave.relatedAuctionId = newMessage.relatedAuctionId;
    }
    if (newMessage.relatedProductId !== undefined) {
      messageToSave.relatedProductId = newMessage.relatedProductId;
    }
    if (newMessage.relatedOrderId !== undefined) {
      messageToSave.relatedOrderId = newMessage.relatedOrderId;
    }
    if (newMessage.isAutoGenerated !== undefined) {
      messageToSave.isAutoGenerated = newMessage.isAutoGenerated;
    }
    
    // Guardar en Firebase Realtime Database usando el ID del mensaje como clave
    const messageRef = ref(realtimeDb, `messages/${newMessage.conversationId}/${newMessage.id}`);
    await firebaseSet(messageRef, messageToSave);
    
    console.log(`‚úÖ Mensaje guardado en Firebase: ${newMessage.id} en conversaci√≥n ${newMessage.conversationId}`);
    return newMessage;
  } catch (error: any) {
    console.error('‚ùå Error guardando mensaje en Firebase:', error);
    
    // Si es un error de permisos, dar informaci√≥n m√°s √∫til
    if (error?.code === 'PERMISSION_DENIED' || error?.message?.includes('permission')) {
      console.error('üîí Error de permisos. Verifica:', {
        fromUserId: message?.fromUserId || 'unknown',
        toUserId: message?.toUserId || 'unknown',
        conversationId: message?.conversationId || 'unknown',
        message: 'El usuario debe ser admin O el mensaje debe ser del usuario autenticado. Si fromUserId es "admin", el usuario debe ser admin.'
      });
    }
    
    throw error;
  }
};

export const getMessages = (conversationId: string, callback: (messages: Message[]) => void): (() => void) => {
  try {
    const messagesRef = ref(realtimeDb, `messages/${conversationId}`);
    
    // Escuchar cambios en tiempo real
    const unsubscribe = onValue(messagesRef, (snapshot) => {
      const data = snapshot.val();
      
      if (!data) {
        callback([]);
        return;
      }
      
      const messages: Message[] = Object.values(data)
        .map((m: any) => ({
          ...m,
          createdAt: new Date(m.createdAt)
        }))
        .sort((a: Message, b: Message) => a.createdAt.getTime() - b.createdAt.getTime());
      
      callback(messages);
    }, (error) => {
      console.error('Error obteniendo mensajes desde Firebase:', error);
      callback([]);
    });
    
    return unsubscribe;
  } catch (error) {
    console.error('Error configurando listener de mensajes:', error);
    callback([]);
    return () => {}; // Retornar funci√≥n vac√≠a si hay error
  }
};

export const getUserConversations = (userId: string, callback: (messages: Message[]) => void): (() => void) => {
  const conversationId = `admin_${userId}`;
  return getMessages(conversationId, callback);
};

export const getAllConversations = (callback: (conversations: Conversation[]) => void): (() => void) => {
  try {
    const messagesRef = ref(realtimeDb, 'messages');
    const conversationsRef = ref(realtimeDb, 'conversations');
    
    // Funci√≥n para procesar conversaciones
    const processConversations = async (messagesData: any, conversationsData: any) => {
      if (!messagesData) {
        callback([]);
        return;
      }
      
      const conversationMap = new Map<string, {
        userId: string;
        username: string;
        userAvatar?: string;
        lastMessage?: Message;
        unreadCount: number;
        updatedAt: Date;
        status?: 'open' | 'closed';
        priority?: 'high' | 'medium' | 'low';
        type?: 'chat' | 'contact' | 'help' | 'ticket';
        closedAt?: Date;
        closedBy?: string;
        reopenedAt?: Date;
      }>();
      
      // Iterar sobre todas las conversaciones
      Object.keys(messagesData).forEach(conversationId => {
        const messages = messagesData[conversationId];
        if (!messages) return;
        
        // Solo procesar conversaciones admin_usuario
        if (conversationId.startsWith('admin_')) {
          const userId = conversationId.replace('admin_', '');
          const messagesArray = Object.values(messages) as any[];
          
          // Obtener datos de conversaci√≥n si existen
          const convData = conversationsData?.[conversationId] || {};
          
          messagesArray.forEach(msg => {
            if (!conversationMap.has(conversationId)) {
              conversationMap.set(conversationId, {
                userId,
                username: msg.fromUsername || '',
                userAvatar: undefined,
                lastMessage: msg,
                unreadCount: 0,
                updatedAt: new Date(msg.createdAt),
                status: convData.status || 'open',
                priority: convData.priority || 'medium',
                type: convData.type || 'chat',
                closedAt: convData.closedAt ? new Date(convData.closedAt) : undefined,
                closedBy: convData.closedBy,
                reopenedAt: convData.reopenedAt ? new Date(convData.reopenedAt) : undefined
              });
            }
            
            const conv = conversationMap.get(conversationId)!;
            
            // Actualizar √∫ltimo mensaje si es m√°s reciente
            const msgDate = new Date(msg.createdAt);
            if (msgDate > conv.updatedAt) {
              conv.lastMessage = msg;
              conv.updatedAt = msgDate;
            }
            
            // Contar no le√≠dos (solo mensajes para admin)
            if (msg.toUserId === 'admin' && !msg.read) {
              conv.unreadCount++;
            }
            
            // Actualizar username si es necesario
            if (msg.toUserId === 'admin') {
              conv.username = msg.fromUsername || '';
            }
          });
        }
      });
      
      const conversations = Array.from(conversationMap.values())
        .map(conv => ({
          id: `admin_${conv.userId}`,
          ...conv,
          lastMessage: conv.lastMessage ? {
            ...conv.lastMessage,
            createdAt: new Date(conv.lastMessage.createdAt)
          } : undefined,
          updatedAt: conv.updatedAt
        }))
        .sort((a, b) => {
          // Ordenar por prioridad primero, luego por fecha
          const priorityOrder = { high: 3, medium: 2, low: 1 };
          const aPriority = priorityOrder[a.priority || 'medium'];
          const bPriority = priorityOrder[b.priority || 'medium'];
          if (aPriority !== bPriority) {
            return bPriority - aPriority;
          }
          return b.updatedAt.getTime() - a.updatedAt.getTime();
        });
      
      callback(conversations);
    };
    
    // Escuchar cambios en mensajes
    const unsubscribeMessages = onValue(messagesRef, async (snapshot) => {
      const messagesData = snapshot.val();
      
      // Obtener datos de conversaciones
      const conversationsSnapshot = await firebaseGet(conversationsRef);
      const conversationsData = conversationsSnapshot.exists() ? conversationsSnapshot.val() : null;
      
      processConversations(messagesData, conversationsData);
    }, (error) => {
      console.error('Error obteniendo conversaciones desde Firebase:', error);
      callback([]);
    });
    
    // Tambi√©n escuchar cambios en estados de conversaciones
    const unsubscribeConversations = onValue(conversationsRef, async () => {
      const messagesSnapshot = await firebaseGet(messagesRef);
      const messagesData = messagesSnapshot.exists() ? messagesSnapshot.val() : null;
      
      const conversationsSnapshot = await firebaseGet(conversationsRef);
      const conversationsData = conversationsSnapshot.exists() ? conversationsSnapshot.val() : null;
      
      processConversations(messagesData, conversationsData);
    });
    
    return () => {
      unsubscribeMessages();
      unsubscribeConversations();
    };
  } catch (error) {
    console.error('Error configurando listener de conversaciones:', error);
    callback([]);
    return () => {}; // Retornar funci√≥n vac√≠a si hay error
  }
};

export const markMessagesAsRead = async (conversationId: string, userId: string) => {
  try {
    const messagesRef = ref(realtimeDb, `messages/${conversationId}`);
    
    // Obtener todos los mensajes de la conversaci√≥n
    const snapshot = await firebaseGet(messagesRef);
    if (!snapshot.exists()) return;
    
    const messages = snapshot.val();
    const updates: any = {};
    
    // Marcar como le√≠dos los mensajes no le√≠dos destinados al usuario
    Object.keys(messages).forEach(key => {
      const msg = messages[key];
      if (msg.toUserId === userId && !msg.read) {
        updates[`messages/${conversationId}/${key}/read`] = true;
      }
    });
    
    if (Object.keys(updates).length > 0) {
      await update(ref(realtimeDb), updates);
      console.log(`‚úÖ Mensajes marcados como le√≠dos en Firebase: ${conversationId}`);
    }
  } catch (error) {
    console.error('‚ùå Error marcando mensajes como le√≠dos en Firebase:', error);
  }
};

export const getUnreadCount = (userId: string, callback: (count: number) => void): (() => void) => {
  const conversationId = `admin_${userId}`;
  return getMessages(conversationId, (messages) => {
    const count = messages.filter(m => m.toUserId === userId && !m.read).length;
    callback(count);
  });
};

export const getAdminUnreadCount = (callback: (count: number) => void): (() => void) => {
  try {
    const messagesRef = ref(realtimeDb, 'messages');
    
    const unsubscribe = onValue(messagesRef, (snapshot) => {
      const data = snapshot.val();
      if (!data) {
        callback(0);
        return;
      }
      
      let count = 0;
      Object.values(data).forEach((conversation: any) => {
        Object.values(conversation).forEach((msg: any) => {
          if (msg.toUserId === 'admin' && !msg.read) {
            count++;
          }
        });
      });
      
      callback(count);
    }, (error) => {
      console.error('Error obteniendo conteo no le√≠dos del admin:', error);
      callback(0);
    });
    
    return unsubscribe;
  } catch (error) {
    console.error('Error configurando listener de conteo admin:', error);
    callback(0);
    return () => {};
  }
};

// Eliminar conversaci√≥n (todos los mensajes de una conversaci√≥n)
export const deleteConversation = async (conversationId: string): Promise<boolean> => {
  try {
    const messagesRef = ref(realtimeDb, `messages/${conversationId}`);
    await remove(messagesRef);
    console.log(`‚úÖ Conversaci√≥n eliminada de Firebase: ${conversationId}`);
    return true;
  } catch (error) {
    console.error('‚ùå Error eliminando conversaci√≥n de Firebase:', error);
    return false;
  }
};

// Eliminar un mensaje espec√≠fico
export const deleteMessage = async (conversationId: string, messageId: string): Promise<boolean> => {
  try {
    const messageRef = ref(realtimeDb, `messages/${conversationId}/${messageId}`);
    await remove(messageRef);
    console.log(`‚úÖ Mensaje eliminado de Firebase: ${messageId}`);
    return true;
  } catch (error) {
    console.error('‚ùå Error eliminando mensaje de Firebase:', error);
    return false;
  }
};

// Eliminar todas las conversaciones
export const deleteAllConversations = async (): Promise<boolean> => {
  try {
    const messagesRef = ref(realtimeDb, 'messages');
    await remove(messagesRef);
    console.log('‚úÖ Todas las conversaciones eliminadas de Firebase');
    return true;
  } catch (error) {
    console.error('‚ùå Error eliminando todas las conversaciones de Firebase:', error);
    return false;
  }
};

// ========== GESTI√ìN DE ESTADOS DE CONVERSACI√ìN ==========

// Obtener estado de conversaci√≥n
export const getConversationStatus = async (conversationId: string): Promise<'open' | 'closed' | null> => {
  try {
    const statusRef = ref(realtimeDb, `conversations/${conversationId}/status`);
    const snapshot = await firebaseGet(statusRef);
    return snapshot.exists() ? snapshot.val() : 'open';
  } catch (error) {
    console.error('Error obteniendo estado de conversaci√≥n:', error);
    return 'open';
  }
};

// Cerrar conversaci√≥n (solo admin)
export const closeConversation = async (conversationId: string, adminId: string): Promise<boolean> => {
  try {
    const conversationRef = ref(realtimeDb, `conversations/${conversationId}`);
    const now = new Date().toISOString();
    
    await firebaseSet(conversationRef, {
      status: 'closed',
      closedAt: now,
      closedBy: adminId
    });
    
    // Crear mensaje autom√°tico de cierre
    const userId = conversationId.replace('admin_', '');
    const closeMessage = createMessage(
      'admin',
      'Administrador',
      userId,
      'Esta conversaci√≥n ha sido cerrada. Si necesit√°s m√°s ayuda, pod√©s iniciar una nueva conversaci√≥n.',
      { isAutoGenerated: true }
    );
    await saveMessage(closeMessage);
    
    console.log(`‚úÖ Conversaci√≥n cerrada: ${conversationId}`);
    return true;
  } catch (error) {
    console.error('‚ùå Error cerrando conversaci√≥n:', error);
    return false;
  }
};

// Reabrir conversaci√≥n (solo admin)
export const reopenConversation = async (conversationId: string, adminId: string): Promise<boolean> => {
  try {
    const conversationRef = ref(realtimeDb, `conversations/${conversationId}`);
    const now = new Date().toISOString();
    
    await firebaseSet(conversationRef, {
      status: 'open',
      reopenedAt: now,
      reopenedBy: adminId
    });
    
    // Crear mensaje autom√°tico de reapertura
    const userId = conversationId.replace('admin_', '');
    const reopenMessage = createMessage(
      'admin',
      'Administrador',
      userId,
      'Esta conversaci√≥n ha sido reabierta. Ya pod√©s responder nuevamente.',
      { isAutoGenerated: true }
    );
    await saveMessage(reopenMessage);
    
    console.log(`‚úÖ Conversaci√≥n reabierta: ${conversationId}`);
    return true;
  } catch (error) {
    console.error('‚ùå Error reabriendo conversaci√≥n:', error);
    return false;
  }
};

// Iniciar conversaci√≥n (usuario o admin)
export const startConversation = async (
  conversationId: string,
  type: 'chat' | 'contact' | 'help' | 'ticket' = 'chat',
  priority: 'high' | 'medium' | 'low' = 'medium'
): Promise<boolean> => {
  try {
    const conversationRef = ref(realtimeDb, `conversations/${conversationId}`);
    const now = new Date().toISOString();
    
    await firebaseSet(conversationRef, {
      status: 'open',
      type,
      priority,
      createdAt: now,
      updatedAt: now
    });
    
    console.log(`‚úÖ Conversaci√≥n iniciada: ${conversationId}`);
    return true;
  } catch (error) {
    console.error('‚ùå Error iniciando conversaci√≥n:', error);
    return false;
  }
};

// Actualizar prioridad de conversaci√≥n
export const updateConversationPriority = async (
  conversationId: string,
  priority: 'high' | 'medium' | 'low'
): Promise<boolean> => {
  try {
    const priorityRef = ref(realtimeDb, `conversations/${conversationId}/priority`);
    await firebaseSet(priorityRef, priority);
    console.log(`‚úÖ Prioridad actualizada: ${conversationId} -> ${priority}`);
    return true;
  } catch (error) {
    console.error('‚ùå Error actualizando prioridad:', error);
    return false;
  }
};

// Verificar si la conversaci√≥n existe
export const conversationExists = async (conversationId: string): Promise<boolean> => {
  try {
    const conversationRef = ref(realtimeDb, `conversations/${conversationId}`);
    const snapshot = await firebaseGet(conversationRef);
    return snapshot.exists();
  } catch (error) {
    console.error('Error verificando existencia de conversaci√≥n:', error);
    return false;
  }
};

// Escuchar estado de conversaci√≥n en tiempo real
export const watchConversationStatus = (
  conversationId: string,
  callback: (status: 'open' | 'closed' | null, exists: boolean) => void
): (() => void) => {
  try {
    const conversationRef = ref(realtimeDb, `conversations/${conversationId}`);
    const unsubscribe = onValue(conversationRef, (snapshot) => {
      if (!snapshot.exists()) {
        // Si no existe la conversaci√≥n, el usuario NO puede enviar mensajes
        callback(null, false);
        return;
      }
      
      const conversationData = snapshot.val();
      const status = conversationData?.status || null;
      callback(status, true);
    }, (error) => {
      console.error('Error escuchando estado de conversaci√≥n:', error);
      callback(null, false);
    });
    
    return unsubscribe;
  } catch (error) {
    console.error('Error configurando listener de estado:', error);
    callback(null, false);
    return () => {};
  }
};

// Mensajes autom√°ticos
export const createAutoMessage = async (
  userId: string,
  username: string,
  type: 'auction_won' | 'purchase' | 'payment_reminder' | 'order_shipped' | 'order_delivered' | 'auction_outbid',
  details: {
    auctionTitle?: string;
    auctionId?: string;
    productName?: string;
    productId?: string;
    orderId?: string;
    amount?: number;
    deadline?: string;
    trackingNumber?: string;
    currentBid?: number;
    minBid?: number;
    paymentDeadline?: string;
  }
): Promise<Message> => {
  // Intentar obtener template personalizado desde Firebase
  let template;
  try {
    template = await getTemplateByType(userId, type);
  } catch (error) {
    console.error('‚ùå Error cargando template:', error);
    template = undefined;
  }
  
  let content = '';
  
  if (template && template.active) {
    // Usar template personalizado
    const variables: Record<string, string | number> = {
      username,
      ...(details.auctionTitle && { auctionTitle: details.auctionTitle }),
      ...(details.productName && { productName: details.productName }),
      ...(details.orderId && { orderId: details.orderId }),
      ...(details.auctionId && { auctionId: details.auctionId }),
      ...(details.amount !== undefined && { amount: details.amount }),
      ...(details.deadline && { deadline: details.deadline }),
      ...(details.trackingNumber && { trackingNumber: details.trackingNumber }),
      ...(details.currentBid !== undefined && { currentBid: details.currentBid }),
      ...(details.minBid !== undefined && { minBid: details.minBid }),
      ...(details.paymentDeadline && { paymentDeadline: details.paymentDeadline })
    };
    
    content = renderTemplate(template, variables);
  } else {
    // Fallback a mensajes por defecto si no hay template activo
    if (type === 'auction_won' && details.auctionTitle) {
      content = `¬°Felicitaciones ${username}! Has ganado la subasta "${details.auctionTitle}" por $${details.amount?.toLocaleString('es-AR') || '0'}. Por favor, contactanos para coordinar el pago y entrega.`;
    } else if (type === 'purchase' && details.productName) {
      content = `Hola ${username}, tu compra de "${details.productName}" ha sido confirmada. Te contactaremos pronto para coordinar el env√≠o.`;
    } else if (type === 'payment_reminder' && details.orderId) {
      content = `Hola ${username}, ten√©s un pago pendiente para el pedido ${details.orderId} por $${details.amount?.toLocaleString('es-AR') || '0'}. Por favor, realiz√° el pago antes de la fecha l√≠mite.`;
    } else if (type === 'order_shipped' && details.orderId) {
      content = `¬°Buenas noticias ${username}! Tu pedido ${details.orderId} ha sido enviado.${details.trackingNumber ? ` C√≥digo de seguimiento: ${details.trackingNumber}` : ''}`;
    } else if (type === 'order_delivered' && details.orderId) {
      content = `¬°Tu pedido lleg√≥ ${username}! Tu pedido ${details.orderId} ha sido entregado exitosamente. ¬°Esperamos que disfrutes tu compra!`;
    } else if (type === 'auction_outbid' && details.auctionTitle) {
      content = `Hola ${username}, has sido superado en la subasta "${details.auctionTitle}". Oferta actual: $${details.currentBid?.toLocaleString('es-AR') || '0'}. ¬øQuer√©s hacer una nueva oferta?`;
    }
  }
  
  return createMessage(
    'admin',
    'Administrador',
    userId,
    content,
    {
      relatedAuctionId: details.auctionId,
      relatedProductId: details.productId,
      relatedOrderId: details.orderId,
      isAutoGenerated: true
    }
  );
};
