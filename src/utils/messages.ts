// Sistema de mensajería entre admin y usuarios
import { Message, Conversation } from '../types';
import { getTemplateByType, renderTemplate } from './messageTemplates';

const MESSAGES_STORAGE_KEY = 'messages';
const CONVERSATIONS_STORAGE_KEY = 'conversations';

export const createMessage = (
  fromUserId: string,
  fromUsername: string,
  toUserId: string,
  content: string,
  options: {
    relatedAuctionId?: string;
    relatedProductId?: string;
    relatedOrderId?: string;
    isAutoGenerated?: boolean;
  } = {}
): Message => {
  const conversationId = toUserId === 'admin' ? `admin_${fromUserId}` : `admin_${toUserId}`;
  
  return {
    id: `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    conversationId,
    fromUserId,
    fromUsername,
    toUserId,
    content,
    read: false,
    createdAt: new Date(),
    ...options
  };
};

export const saveMessage = (message: Message) => {
  try {
    const saved = localStorage.getItem(MESSAGES_STORAGE_KEY);
    const messages: Message[] = saved ? JSON.parse(saved) : [];
    
    // Convertir createdAt a Date
    const newMessage = {
      ...message,
      createdAt: message.createdAt instanceof Date ? message.createdAt : new Date(message.createdAt)
    };
    
    messages.push(newMessage);
    localStorage.setItem(MESSAGES_STORAGE_KEY, JSON.stringify(messages));
    
    // Actualizar conversación
    updateConversation(newMessage);
    
    return newMessage;
  } catch (error) {
    console.error('Error guardando mensaje:', error);
    throw error;
  }
};

export const getMessages = (conversationId: string): Message[] => {
  try {
    const saved = localStorage.getItem(MESSAGES_STORAGE_KEY);
    if (!saved) return [];
    
    const messages: Message[] = JSON.parse(saved);
    return messages
      .filter(m => m.conversationId === conversationId)
      .map(m => ({
        ...m,
        createdAt: new Date(m.createdAt)
      }))
      .sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime());
  } catch (error) {
    console.error('Error obteniendo mensajes:', error);
    return [];
  }
};

export const getUserConversations = (userId: string): Message[] => {
  try {
    const saved = localStorage.getItem(MESSAGES_STORAGE_KEY);
    if (!saved) return [];
    
    const messages: Message[] = JSON.parse(saved);
    const conversationId = `admin_${userId}`;
    
    return messages
      .filter(m => m.conversationId === conversationId)
      .map(m => ({
        ...m,
        createdAt: new Date(m.createdAt)
      }))
      .sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime());
  } catch (error) {
    console.error('Error obteniendo conversaciones del usuario:', error);
    return [];
  }
};

export const getAllConversations = (): Conversation[] => {
  try {
    const saved = localStorage.getItem(MESSAGES_STORAGE_KEY);
    if (!saved) return [];
    
    const messages: Message[] = JSON.parse(saved);
    const conversationMap = new Map<string, {
      userId: string;
      username: string;
      userAvatar?: string;
      lastMessage?: Message;
      unreadCount: number;
      updatedAt: Date;
    }>();
    
    messages.forEach(msg => {
      // Solo conversaciones con admin
      if (msg.toUserId === 'admin' || msg.fromUserId === 'admin') {
        const userId = msg.toUserId === 'admin' ? msg.fromUserId : msg.toUserId;
        const conversationId = `admin_${userId}`;
        
        if (!conversationMap.has(conversationId)) {
          conversationMap.set(conversationId, {
            userId,
            username: msg.toUserId === 'admin' ? msg.fromUsername : '',
            userAvatar: undefined,
            lastMessage: msg,
            unreadCount: 0,
            updatedAt: new Date(msg.createdAt)
          });
        }
        
        const conv = conversationMap.get(conversationId)!;
        
        // Actualizar último mensaje si es más reciente
        const msgDate = new Date(msg.createdAt);
        if (msgDate > conv.updatedAt) {
          conv.lastMessage = msg;
          conv.updatedAt = msgDate;
        }
        
        // Contar no leídos (solo mensajes para admin)
        if (msg.toUserId === 'admin' && !msg.read) {
          conv.unreadCount++;
        }
        
        // Actualizar username si es necesario
        if (msg.toUserId === 'admin') {
          conv.username = msg.fromUsername;
        }
      }
    });
    
    return Array.from(conversationMap.values())
      .map(conv => ({
        id: `admin_${conv.userId}`,
        ...conv,
        lastMessage: conv.lastMessage ? {
          ...conv.lastMessage,
          createdAt: new Date(conv.lastMessage.createdAt)
        } : undefined,
        updatedAt: conv.updatedAt
      }))
      .sort((a, b) => b.updatedAt.getTime() - a.updatedAt.getTime());
  } catch (error) {
    console.error('Error obteniendo conversaciones:', error);
    return [];
  }
};

export const markMessagesAsRead = (conversationId: string, userId: string) => {
  try {
    const saved = localStorage.getItem(MESSAGES_STORAGE_KEY);
    if (!saved) return;
    
    const messages: Message[] = JSON.parse(saved);
    const updated = messages.map(msg => {
      if (msg.conversationId === conversationId && msg.toUserId === userId && !msg.read) {
        return { ...msg, read: true };
      }
      return msg;
    });
    
    localStorage.setItem(MESSAGES_STORAGE_KEY, JSON.stringify(updated));
  } catch (error) {
    console.error('Error marcando mensajes como leídos:', error);
  }
};

export const getUnreadCount = (userId: string): number => {
  try {
    const saved = localStorage.getItem(MESSAGES_STORAGE_KEY);
    if (!saved) return 0;
    
    const messages: Message[] = JSON.parse(saved);
    const conversationId = `admin_${userId}`;
    
    return messages.filter(
      m => m.conversationId === conversationId && m.toUserId === userId && !m.read
    ).length;
  } catch (error) {
    console.error('Error obteniendo conteo no leídos:', error);
    return 0;
  }
};

export const getAdminUnreadCount = (): number => {
  try {
    const saved = localStorage.getItem(MESSAGES_STORAGE_KEY);
    if (!saved) return 0;
    
    const messages: Message[] = JSON.parse(saved);
    return messages.filter(m => m.toUserId === 'admin' && !m.read).length;
  } catch (error) {
    console.error('Error obteniendo conteo no leídos del admin:', error);
    return 0;
  }
};

const updateConversation = (message: Message) => {
  // Esto se usa internamente para mantener actualizadas las conversaciones
  // Las conversaciones se calculan dinámicamente desde los mensajes
};

// Eliminar conversación (todos los mensajes de una conversación)
export const deleteConversation = (conversationId: string) => {
  try {
    const saved = localStorage.getItem(MESSAGES_STORAGE_KEY);
    if (!saved) return;
    
    const messages: Message[] = JSON.parse(saved);
    const filtered = messages.filter(m => m.conversationId !== conversationId);
    
    localStorage.setItem(MESSAGES_STORAGE_KEY, JSON.stringify(filtered));
    return true;
  } catch (error) {
    console.error('Error eliminando conversación:', error);
    return false;
  }
};

// Eliminar un mensaje específico
export const deleteMessage = (messageId: string) => {
  try {
    const saved = localStorage.getItem(MESSAGES_STORAGE_KEY);
    if (!saved) return false;
    
    const messages: Message[] = JSON.parse(saved);
    const filtered = messages.filter(m => m.id !== messageId);
    
    localStorage.setItem(MESSAGES_STORAGE_KEY, JSON.stringify(filtered));
    return true;
  } catch (error) {
    console.error('Error eliminando mensaje:', error);
    return false;
  }
};

// Eliminar todas las conversaciones
export const deleteAllConversations = () => {
  try {
    localStorage.removeItem(MESSAGES_STORAGE_KEY);
    return true;
  } catch (error) {
    console.error('Error eliminando todas las conversaciones:', error);
    return false;
  }
};

// Mensajes automáticos
export const createAutoMessage = (
  userId: string,
  username: string,
  type: 'auction_won' | 'purchase' | 'payment_reminder' | 'order_shipped' | 'order_delivered' | 'auction_outbid',
  details: {
    auctionTitle?: string;
    auctionId?: string;
    productName?: string;
    productId?: string;
    orderId?: string;
    amount?: number;
    deadline?: string;
    trackingNumber?: string;
    currentBid?: number;
    minBid?: number;
    paymentDeadline?: string;
  }
): Message => {
  // Intentar obtener template personalizado
  const template = getTemplateByType(type);
  
  let content = '';
  
  if (template && template.active) {
    // Usar template personalizado
    const variables: Record<string, string | number> = {
      username,
      ...(details.auctionTitle && { auctionTitle: details.auctionTitle }),
      ...(details.productName && { productName: details.productName }),
      ...(details.orderId && { orderId: details.orderId }),
      ...(details.auctionId && { auctionId: details.auctionId }),
      ...(details.amount !== undefined && { amount: details.amount }),
      ...(details.deadline && { deadline: details.deadline }),
      ...(details.trackingNumber && { trackingNumber: details.trackingNumber }),
      ...(details.currentBid !== undefined && { currentBid: details.currentBid }),
      ...(details.minBid !== undefined && { minBid: details.minBid }),
      ...(details.paymentDeadline && { paymentDeadline: details.paymentDeadline })
    };
    
    content = renderTemplate(template, variables);
  } else {
    // Fallback a mensajes por defecto si no hay template activo
    if (type === 'auction_won' && details.auctionTitle) {
      content = `¡Felicitaciones ${username}! Has ganado la subasta "${details.auctionTitle}" por $${details.amount?.toLocaleString('es-AR') || '0'}. Por favor, contactanos para coordinar el pago y entrega.`;
    } else if (type === 'purchase' && details.productName) {
      content = `Hola ${username}, tu compra de "${details.productName}" ha sido confirmada. Te contactaremos pronto para coordinar el envío.`;
    } else if (type === 'payment_reminder' && details.orderId) {
      content = `Hola ${username}, tenés un pago pendiente para el pedido ${details.orderId} por $${details.amount?.toLocaleString('es-AR') || '0'}. Por favor, realizá el pago antes de la fecha límite.`;
    } else if (type === 'order_shipped' && details.orderId) {
      content = `¡Buenas noticias ${username}! Tu pedido ${details.orderId} ha sido enviado.${details.trackingNumber ? ` Código de seguimiento: ${details.trackingNumber}` : ''}`;
    } else if (type === 'order_delivered' && details.orderId) {
      content = `¡Tu pedido llegó ${username}! Tu pedido ${details.orderId} ha sido entregado exitosamente. ¡Esperamos que disfrutes tu compra!`;
    } else if (type === 'auction_outbid' && details.auctionTitle) {
      content = `Hola ${username}, has sido superado en la subasta "${details.auctionTitle}". Oferta actual: $${details.currentBid?.toLocaleString('es-AR') || '0'}. ¿Querés hacer una nueva oferta?`;
    }
  }
  
  return createMessage(
    'admin',
    'Administrador',
    userId,
    content,
    {
      relatedAuctionId: details.auctionId,
      relatedProductId: details.productId,
      relatedOrderId: details.orderId,
      isAutoGenerated: true
    }
  );
};

