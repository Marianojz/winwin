// Sistema de mensajer√≠a entre admin y usuarios
import { ref, push, set as firebaseSet, get as firebaseGet, update, onValue, off, remove } from 'firebase/database';
import { realtimeDb } from '../config/firebase';
import { Message, Conversation } from '../types';
import { getTemplateByType, renderTemplate } from './messageTemplates';

export const createMessage = (
  fromUserId: string,
  fromUsername: string,
  toUserId: string,
  content: string,
  options: {
    relatedAuctionId?: string;
    relatedProductId?: string;
    relatedOrderId?: string;
    isAutoGenerated?: boolean;
  } = {}
): Message => {
  const conversationId = toUserId === 'admin' ? `admin_${fromUserId}` : `admin_${toUserId}`;
  
  return {
    id: `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    conversationId,
    fromUserId,
    fromUsername,
    toUserId,
    content,
    read: false,
    createdAt: new Date(),
    ...options
  };
};

export const saveMessage = async (message: Message): Promise<Message> => {
  try {
    // Convertir createdAt a Date
    const newMessage = {
      ...message,
      createdAt: message.createdAt instanceof Date ? message.createdAt : new Date(message.createdAt)
    };
    
    // Filtrar campos undefined (Firebase no los permite)
    const messageToSave: any = {
      id: newMessage.id,
      conversationId: newMessage.conversationId,
      fromUserId: newMessage.fromUserId,
      fromUsername: newMessage.fromUsername,
      toUserId: newMessage.toUserId,
      content: newMessage.content,
      read: newMessage.read || false,
      createdAt: newMessage.createdAt.toISOString()
    };
    
    // Solo agregar campos opcionales si no son undefined
    if (newMessage.relatedAuctionId !== undefined) {
      messageToSave.relatedAuctionId = newMessage.relatedAuctionId;
    }
    if (newMessage.relatedProductId !== undefined) {
      messageToSave.relatedProductId = newMessage.relatedProductId;
    }
    if (newMessage.relatedOrderId !== undefined) {
      messageToSave.relatedOrderId = newMessage.relatedOrderId;
    }
    if (newMessage.isAutoGenerated !== undefined) {
      messageToSave.isAutoGenerated = newMessage.isAutoGenerated;
    }
    
    // Guardar en Firebase Realtime Database usando el ID del mensaje como clave
    const messageRef = ref(realtimeDb, `messages/${newMessage.conversationId}/${newMessage.id}`);
    await firebaseSet(messageRef, messageToSave);
    
    console.log(`‚úÖ Mensaje guardado en Firebase: ${newMessage.id} en conversaci√≥n ${newMessage.conversationId}`);
    return newMessage;
  } catch (error: any) {
    console.error('‚ùå Error guardando mensaje en Firebase:', error);
    
    // Si es un error de permisos, dar informaci√≥n m√°s √∫til
    if (error?.code === 'PERMISSION_DENIED' || error?.message?.includes('permission')) {
      console.error('üîí Error de permisos. Verifica:', {
        fromUserId: message?.fromUserId || 'unknown',
        toUserId: message?.toUserId || 'unknown',
        conversationId: message?.conversationId || 'unknown',
        message: 'El usuario debe ser admin O el mensaje debe ser del usuario autenticado. Si fromUserId es "admin", el usuario debe ser admin.'
      });
    }
    
    throw error;
  }
};

export const getMessages = (conversationId: string, callback: (messages: Message[]) => void): (() => void) => {
  try {
    const messagesRef = ref(realtimeDb, `messages/${conversationId}`);
    
    // Escuchar cambios en tiempo real
    const unsubscribe = onValue(messagesRef, (snapshot) => {
      const data = snapshot.val();
      
      if (!data) {
        callback([]);
        return;
      }
      
      const messages: Message[] = Object.values(data)
        .map((m: any) => ({
          ...m,
          createdAt: new Date(m.createdAt)
        }))
        .sort((a: Message, b: Message) => a.createdAt.getTime() - b.createdAt.getTime());
      
      callback(messages);
    }, (error) => {
      console.error('Error obteniendo mensajes desde Firebase:', error);
      callback([]);
    });
    
    return unsubscribe;
  } catch (error) {
    console.error('Error configurando listener de mensajes:', error);
    callback([]);
    return () => {}; // Retornar funci√≥n vac√≠a si hay error
  }
};

export const getUserConversations = (userId: string, callback: (messages: Message[]) => void): (() => void) => {
  const conversationId = `admin_${userId}`;
  return getMessages(conversationId, callback);
};

export const getAllConversations = (callback: (conversations: Conversation[]) => void): (() => void) => {
  try {
    const messagesRef = ref(realtimeDb, 'messages');
    
    // Escuchar cambios en tiempo real
    const unsubscribe = onValue(messagesRef, (snapshot) => {
      const data = snapshot.val();
      
      if (!data) {
        callback([]);
        return;
      }
      
      const conversationMap = new Map<string, {
        userId: string;
        username: string;
        userAvatar?: string;
        lastMessage?: Message;
        unreadCount: number;
        updatedAt: Date;
      }>();
      
      // Iterar sobre todas las conversaciones
      Object.keys(data).forEach(conversationId => {
        const messages = data[conversationId];
        if (!messages) return;
        
        // Solo procesar conversaciones admin_usuario
        if (conversationId.startsWith('admin_')) {
          const userId = conversationId.replace('admin_', '');
          const messagesArray = Object.values(messages) as any[];
          
          messagesArray.forEach(msg => {
            if (!conversationMap.has(conversationId)) {
              conversationMap.set(conversationId, {
                userId,
                username: msg.fromUsername || '',
                userAvatar: undefined,
                lastMessage: msg,
                unreadCount: 0,
                updatedAt: new Date(msg.createdAt)
              });
            }
            
            const conv = conversationMap.get(conversationId)!;
            
            // Actualizar √∫ltimo mensaje si es m√°s reciente
            const msgDate = new Date(msg.createdAt);
            if (msgDate > conv.updatedAt) {
              conv.lastMessage = msg;
              conv.updatedAt = msgDate;
            }
            
            // Contar no le√≠dos (solo mensajes para admin)
            if (msg.toUserId === 'admin' && !msg.read) {
              conv.unreadCount++;
            }
            
            // Actualizar username si es necesario
            if (msg.toUserId === 'admin') {
              conv.username = msg.fromUsername || '';
            }
          });
        }
      });
      
      const conversations = Array.from(conversationMap.values())
        .map(conv => ({
          id: `admin_${conv.userId}`,
          ...conv,
          lastMessage: conv.lastMessage ? {
            ...conv.lastMessage,
            createdAt: new Date(conv.lastMessage.createdAt)
          } : undefined,
          updatedAt: conv.updatedAt
        }))
        .sort((a, b) => b.updatedAt.getTime() - a.updatedAt.getTime());
      
      callback(conversations);
    }, (error) => {
      console.error('Error obteniendo conversaciones desde Firebase:', error);
      callback([]);
    });
    
    return unsubscribe;
  } catch (error) {
    console.error('Error configurando listener de conversaciones:', error);
    callback([]);
    return () => {}; // Retornar funci√≥n vac√≠a si hay error
  }
};

export const markMessagesAsRead = async (conversationId: string, userId: string) => {
  try {
    const messagesRef = ref(realtimeDb, `messages/${conversationId}`);
    
    // Obtener todos los mensajes de la conversaci√≥n
    const snapshot = await firebaseGet(messagesRef);
    if (!snapshot.exists()) return;
    
    const messages = snapshot.val();
    const updates: any = {};
    
    // Marcar como le√≠dos los mensajes no le√≠dos destinados al usuario
    Object.keys(messages).forEach(key => {
      const msg = messages[key];
      if (msg.toUserId === userId && !msg.read) {
        updates[`messages/${conversationId}/${key}/read`] = true;
      }
    });
    
    if (Object.keys(updates).length > 0) {
      await update(ref(realtimeDb), updates);
      console.log(`‚úÖ Mensajes marcados como le√≠dos en Firebase: ${conversationId}`);
    }
  } catch (error) {
    console.error('‚ùå Error marcando mensajes como le√≠dos en Firebase:', error);
  }
};

export const getUnreadCount = (userId: string, callback: (count: number) => void): (() => void) => {
  const conversationId = `admin_${userId}`;
  return getMessages(conversationId, (messages) => {
    const count = messages.filter(m => m.toUserId === userId && !m.read).length;
    callback(count);
  });
};

export const getAdminUnreadCount = (callback: (count: number) => void): (() => void) => {
  try {
    const messagesRef = ref(realtimeDb, 'messages');
    
    const unsubscribe = onValue(messagesRef, (snapshot) => {
      const data = snapshot.val();
      if (!data) {
        callback(0);
        return;
      }
      
      let count = 0;
      Object.values(data).forEach((conversation: any) => {
        Object.values(conversation).forEach((msg: any) => {
          if (msg.toUserId === 'admin' && !msg.read) {
            count++;
          }
        });
      });
      
      callback(count);
    }, (error) => {
      console.error('Error obteniendo conteo no le√≠dos del admin:', error);
      callback(0);
    });
    
    return unsubscribe;
  } catch (error) {
    console.error('Error configurando listener de conteo admin:', error);
    callback(0);
    return () => {};
  }
};

// Eliminar conversaci√≥n (todos los mensajes de una conversaci√≥n)
export const deleteConversation = async (conversationId: string): Promise<boolean> => {
  try {
    const messagesRef = ref(realtimeDb, `messages/${conversationId}`);
    await remove(messagesRef);
    console.log(`‚úÖ Conversaci√≥n eliminada de Firebase: ${conversationId}`);
    return true;
  } catch (error) {
    console.error('‚ùå Error eliminando conversaci√≥n de Firebase:', error);
    return false;
  }
};

// Eliminar un mensaje espec√≠fico
export const deleteMessage = async (conversationId: string, messageId: string): Promise<boolean> => {
  try {
    const messageRef = ref(realtimeDb, `messages/${conversationId}/${messageId}`);
    await remove(messageRef);
    console.log(`‚úÖ Mensaje eliminado de Firebase: ${messageId}`);
    return true;
  } catch (error) {
    console.error('‚ùå Error eliminando mensaje de Firebase:', error);
    return false;
  }
};

// Eliminar todas las conversaciones
export const deleteAllConversations = async (): Promise<boolean> => {
  try {
    const messagesRef = ref(realtimeDb, 'messages');
    await remove(messagesRef);
    console.log('‚úÖ Todas las conversaciones eliminadas de Firebase');
    return true;
  } catch (error) {
    console.error('‚ùå Error eliminando todas las conversaciones de Firebase:', error);
    return false;
  }
};

// Mensajes autom√°ticos
export const createAutoMessage = (
  userId: string,
  username: string,
  type: 'auction_won' | 'purchase' | 'payment_reminder' | 'order_shipped' | 'order_delivered' | 'auction_outbid',
  details: {
    auctionTitle?: string;
    auctionId?: string;
    productName?: string;
    productId?: string;
    orderId?: string;
    amount?: number;
    deadline?: string;
    trackingNumber?: string;
    currentBid?: number;
    minBid?: number;
    paymentDeadline?: string;
  }
): Message => {
  // Intentar obtener template personalizado
  const template = getTemplateByType(type);
  
  let content = '';
  
  if (template && template.active) {
    // Usar template personalizado
    const variables: Record<string, string | number> = {
      username,
      ...(details.auctionTitle && { auctionTitle: details.auctionTitle }),
      ...(details.productName && { productName: details.productName }),
      ...(details.orderId && { orderId: details.orderId }),
      ...(details.auctionId && { auctionId: details.auctionId }),
      ...(details.amount !== undefined && { amount: details.amount }),
      ...(details.deadline && { deadline: details.deadline }),
      ...(details.trackingNumber && { trackingNumber: details.trackingNumber }),
      ...(details.currentBid !== undefined && { currentBid: details.currentBid }),
      ...(details.minBid !== undefined && { minBid: details.minBid }),
      ...(details.paymentDeadline && { paymentDeadline: details.paymentDeadline })
    };
    
    content = renderTemplate(template, variables);
  } else {
    // Fallback a mensajes por defecto si no hay template activo
    if (type === 'auction_won' && details.auctionTitle) {
      content = `¬°Felicitaciones ${username}! Has ganado la subasta "${details.auctionTitle}" por $${details.amount?.toLocaleString('es-AR') || '0'}. Por favor, contactanos para coordinar el pago y entrega.`;
    } else if (type === 'purchase' && details.productName) {
      content = `Hola ${username}, tu compra de "${details.productName}" ha sido confirmada. Te contactaremos pronto para coordinar el env√≠o.`;
    } else if (type === 'payment_reminder' && details.orderId) {
      content = `Hola ${username}, ten√©s un pago pendiente para el pedido ${details.orderId} por $${details.amount?.toLocaleString('es-AR') || '0'}. Por favor, realiz√° el pago antes de la fecha l√≠mite.`;
    } else if (type === 'order_shipped' && details.orderId) {
      content = `¬°Buenas noticias ${username}! Tu pedido ${details.orderId} ha sido enviado.${details.trackingNumber ? ` C√≥digo de seguimiento: ${details.trackingNumber}` : ''}`;
    } else if (type === 'order_delivered' && details.orderId) {
      content = `¬°Tu pedido lleg√≥ ${username}! Tu pedido ${details.orderId} ha sido entregado exitosamente. ¬°Esperamos que disfrutes tu compra!`;
    } else if (type === 'auction_outbid' && details.auctionTitle) {
      content = `Hola ${username}, has sido superado en la subasta "${details.auctionTitle}". Oferta actual: $${details.currentBid?.toLocaleString('es-AR') || '0'}. ¬øQuer√©s hacer una nueva oferta?`;
    }
  }
  
  return createMessage(
    'admin',
    'Administrador',
    userId,
    content,
    {
      relatedAuctionId: details.auctionId,
      relatedProductId: details.productId,
      relatedOrderId: details.orderId,
      isAutoGenerated: true
    }
  );
};
